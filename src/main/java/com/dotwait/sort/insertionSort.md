## 插入排序分析

**描述：**

> 插入排序：构建有序序列，对于未排序的数据，在已排序序列中从后向前扫描，找到正确的位置插入。适用于数据量较小的情况。
>
> ![img](http://www.goyth.com/2018/02/08/straightInsertionSort/insertSort.png)

**代码如下：**

```java
public static void sortAscend(int[] array) {
    for (int i = 1; i < array.length; i++) {
        int key = array[i];
        int j = i - 1;
        for (; j >= 0 && key < array[j]; j--) {
            array[j + 1] = array[j];
        }
        array[j + 1] = key;
    }
}
```

**算法分析：**

假定第i行的每次执行时间为$c_i$，$c_i$是一个常量。$t_i$表示对某个值i第5行for循环测试的次数

| 代码行号 | 代价  | 次数                      |
| -------- | ----- | ------------------------- |
| 2        | $c_1$ | n                         |
| 3        | $c_2$ | n-1                       |
| 4        | $c_3$ | n-1                       |
| 5        | $c_4$ | $\sum_{i=2}^{n}{t_i}$     |
| 6        | $c_5$ | $\sum_{i=2}^{n}{(t_i-1)}$ |
| 8        | $c_6$ | n-1                       |

**运行时间：**

$T(n)=c_1n+c_2(n-1)+c_3(n-1)+c_4\sum_{i=2}^{n}{t_i}+c_5\sum_{i=2}^{n}{(t_i-1)}+c_6(n-1)$

**最佳情况：**输入的数组已经排好序，此时$t_i$=1，$O(n)$

$T(n)=c_1n+c_2(n-1)+c_3(n-1)+c_4(n-1)+c_6(n-1)$

​		$=(c_1+c_2+c_3+c_4+c_6)n-(c_2+c_3+c_4+c_6)$

**最坏情况：**输入的数组已反向排序，$t_i=i$，$O(n^2)$

$T(n)=c_1n+c_2(n-1)+c_3(n-1)+c_4(\frac{n(n+1)}{2}-1)+c_5(\frac{n(n-1)}{2})+c_6(n-1)$

​		$=(\frac{c_4}{2}+\frac{c_5}{2})n^2+(c_1+c_2+c_3+\frac{c_4}{2}-\frac{c_5}{2}+c_6)n+-(c_2+c_3+c_4+c_6)$

**时间复杂度：**$O(n^2)$

**空间复杂度：**$O(1)$